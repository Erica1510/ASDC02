## Сортировка пузырьком (Bubble Sort)

Алгоритм состоит из повторяющихся проходов по сортируемому массиву. За каждый проход элементы последовательно сравниваются попарно и,
если порядок в паре неверный, выполняется перестановка элементов. Проходы по массиву повторяются N-1 раз или до тех пор,
пока на очередном проходе не окажется, что обмены больше не нужны, что означает — массив отсортирован.
При каждом проходе алгоритма по внутреннему циклу, очередной наибольший элемент массива ставится на своё 
место в конце массива рядом с предыдущим «наибольшим элементом», а наименьший элемент перемещается на одну позицию к началу массива 
(«всплывает» до нужной позиции, как пузырёк в воде — отсюда и название алгоритма).

## Сортировка вставками (Insertion Sort)

На вход алгоритма подаётся последовательность n чисел: a_{1},a_{2},...,a_{n}}a_{1},a_{2},...,a_{n}. 
Сортируемые числа также называют ключами. Входная последовательность на практике представляется в виде массива с n элементами. 
В начальный момент отсортированная последовательность пуста. На каждом шаге алгоритма выбирается один из элементов входных данных
и помещается на нужную позицию в уже отсортированной последовательности до тех пор, пока набор входных данных не будет исчерпан.
В любой момент времени в отсортированной последовательности элементы удовлетворяют требованиям к выходным данным алгоритма[3].

Данный алгоритм можно ускорить при помощи использования бинарного поиска для нахождения места 
текущему элементу в отсортированной части. Проблема с долгим сдвигом массива вправо решается при помощи смены указателей[4].

## Сортировка выбором (Selection Sort)
1. находим номер минимального значения в текущем списке
2. производим обмен этого значения со значением первой неотсортированной позиции 
3. (обмен не нужен, если минимальный элемент уже находится на данной позиции)
4. теперь сортируем хвост списка, исключив из рассмотрения уже отсортированные элементы

## Быстрая сортировка (Quick Sort)

Общая идея алгоритма состоит в следующем:

Выбрать из массива элемент, называемый опорным. Это может быть любой из элементов массива.
От выбора опорного элемента не зависит корректность алгоритма, но в отдельных случаях может сильно зависеть его эффективность.
Сравнить все остальные элементы с опорным и переставить их в массиве так, чтобы разбить массив на три непрерывных отрезка,
следующих друг за другом: «элементы меньшие опорного», «равные» и «большие».
Для отрезков «меньших» и «больших» значений выполнить рекурсивно ту же последовательность операций, если длина отрезка больше единицы.

## Сортировка Шелла (Shell Sort)

При сортировке Шелла сначала сравниваются и сортируются между собой значения, стоящие один от другого на некотором расстоянииd 
(о выборе значения. После этого процедура повторяется для некоторых меньших значений d, а завершается сортировка Шелла 
упорядочиванием элементов при d=1 (то есть обычной сортировкой вставками). 
Эффективность сортировки Шелла в определённых случаях обеспечивается тем, что элементы «быстрее» встают на свои места 
(в простых методах сортировки, например, пузырьковой, каждая перестановка двух элементов уменьшает количество инверсий в списке максимум на 1, 
а при сортировке Шелла это число может быть больше).

Невзирая на то, что сортировка Шелла во многих случаях медленнее, чем быстрая сортировка, она имеет ряд преимуществ:

отсутствие потребности в памяти под стек;
отсутствие деградации при неудачных наборах данных — быстрая сортировка легко деградирует до O(n²), 
что хуже, чем худшее гарантированное время для сортировки Шелла.
Пирамидальная сортировка (Heap Sort)

## Пирамидальная сортировка (или сортировка кучей, HeapSort) 
метод сортировки сравнением, основанный на такой структуре данных как двоичная куча. 
Она похожа на сортировку выбором, где мы сначала ищем максимальный элемент и помещаем его в конец.
Далее мы повторяем ту же операцию для оставшихся элементов

## Сортировка слиянием (merge sort) 


Для решения задачи сортировки эти три этапа выглядят так:
1.	Сортируемый массив разбивается на две части примерно одинакового размера;
2.	Каждая из получившихся частей сортируется отдельно, например — тем же самым алгоритмом;
3.	Два упорядоченных массива половинного размера соединяются в один.
1.1. — 2.1. Рекурсивное разбиение задачи на меньшие происходит до тех пор, пока размер массива не достигнет единицы 
(любой массив длины 1 можно считать упорядоченным).
3.1. Соединение двух упорядоченных массивов в один.
Основную идею слияния двух отсортированных массивов можно объяснить на следующем примере. 
Пусть мы имеем два уже отсортированных по возрастанию подмассива. 
Тогда:
3.2. Слияние двух подмассивов в третий результирующий массив.
На каждом шаге мы берём меньший из двух первых элементов подмассивов и записываем его в результирующий массив. 
Счётчики номеров элементов результирующего массива и подмассива, из которого был взят элемент, увеличиваем на 1.
3.3. «Прицепление» остатка.
Когда один из подмассивов закончился, мы добавляем все оставшиеся элементы второго подмассива в результирующий массив.







 

